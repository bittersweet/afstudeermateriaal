\chapter{Uitgewerkte adviezen}

\section{Introductie}

In dit gedeelte van het document zal ik dieper ingaan op de adviezen die ik net heb opgesteld. Ik sommige gevallen zal ik een aantal opties aandragen waarna ik mijn persoonlijke voorkeur uitspreek.

\paragraph{Om mijn adviezen toegankelijk te houden voor de meeste bedrijven en studenten heb ik mijn adviezen en keuzes gebaseerd op open source software.}

\section{{\sc scm} systeem}

\subsection{Voordelen}

Gebruik maken van een {\sc scm} systeem bied ontzettend veel voordelen. Het opslaan van verschillende versies van bestanden tijdens het ontwikkelproces is van onmisbaar belang. Het biedt je veiligheid want je kan altijd terug gaan naar een vorige versie als er bijvoorbeeld een fout in de code is geslopen. Het zorgt er ook voor dat je goed kan samenwerken omdat elke werknemer individueel kan werken aan zijn of haar eigen versie van een project. Hierdoor kan het ook een overzicht bieden van wie wat doet, je kan precies zien wat is aangepast in een bepaald bestand en door wie.

Naast deze op zich voor de hand liggende voordelen biedt het ook stabiliteit. Doordat je met een {\sc scm} systeem de mogelijkheid hebt om te \emph{branchen} kan je gelijktijdig meerdere versies van een project hebben. Bijvoorbeeld \emph{stable} voor de stabiele versie en een \emph{development} versie waarin gewerkt wordt. Doordat je wijzigingen in een speciale ontwikkel branch uitvoert, blijft je stable branch onaangeraakt en dus altijd stabiel. In een ideale situatie worden alle wijzingingen uitvoerig getest voordat ze in de stabiele versie worden geïntegreerd. Omdat je dus kan werken in een gescheiden branch is het veilig om te experimenteren, wat in mijn ogen een groot voordeel is.

\subsection{Tools}

Tegenwoordig zijn er vele {\sc scm} systemen om uit te kiezen. Een greep uit het aanbod: \emph{Subversion, Git, Mercurial} en \emph{Bazaar}. Eigenlijk bieden ze allemaal ongeveer dezelfde functionaliteit dus de keuze om één hiervan uit te kiezen zal van andere factoren afhangen.

Van dit rijtje is Subversion eigenlijk van de oude school. Het is een systeem wat gebaseerd is op een centrale repository waarin alle wijzigingen worden bijgehouden. De andere behoren tot de zogenaamde {\sc dvcs} familie, oftewel Distributed Concurrent Version System.

Het voordeel van een {\sc dvcs} is dat je geen centrale server nodig hebt, iedereen draait een lokale repository. Bij Subversion moet je wel gebruik maken van één centrale server waar iedereen verbinding mee moet leggen om te kunnen werken. Omdat je dus je eigen repository draait kan je commits maken zonder dat je verbinding hebt met een server, je kan dus offline en onderweg werken. Hiernaast is het een stuk gemakkelijker en sneller om branches te maken omdat alles lokaal gebeurd, in plaats van over het netwerk. Bij Subversion is dat een log proces wat erg lang duurt, bij een systeem als Git zal een branch van hetzelfde project enkele seconden duren in plaats van 3 minuten. Hierdoor wordt het dus bijvoorbeeld makkelijk om even een branch aan te maken om met een bepaald idee te experimenteren. Mocht het niet bevallen kan deze branch gemakkelijk weer verwijderd worden. Omdat het een snelle procedure is word je niet uit je workflow gehaald wat met Subversion wel het geval zou zijn.

In de meeste gevallen richt je een {\sc dvcs} ook zo in dat iedereen wijzigingen verstuurd (\emph{pushed}) naar een centrale server, dat zorgt voor een goed overzicht. Doordat iedereen zelf kiest wat er naar deze server wordt gepushed houd je een nette repository. Hij wordt niet vervuild door commits die bijvoorbeeld verkeerd waren of waar iemand nog niet mee klaar is.

Een {\sc dvcs} geniet mijn voorkeur al door deze punten maar Subversion heeft iets wat in haar voordeel speelt. Doordat het van de genoemde tools de oudste is zijn er erg veel verschillende applicaties en pakketten voor beschikbaar. Zo zijn er erg veel grafische programma's om met Subversion te kunnen werken, in tegenstelling tot de andere waarbij het tot nu toe meer een commandline aangelegenheid blijft.

Als je alleen de gedistribueerde pakketten bekijkt zijn er een aantal voordelen die Git hierin weer afscheid van de rest. Ik zal ze kort benoemen.

\begin{itemize}
  \item Goedkope local branching. Git geeft je de mogelijkheid zoveel lokale branches aan te maken als je wilt, waarbij het creëren, mergen en deleten hiervan maar enkele seconde duurt. De andere systemen raden aan dat de beste branch een kloon is van de repository in een andere directory en bieden niet deze handigheid.
  \item Git is ontzettend snel\cite{whygitisbetterthanx}. Omdat het ontworpen is voor gebruik aan de Linux kernel, waren gebruik maken van grote repositories en snelheid uitgangspunten tijdens te ontwikkeling, en dat is te merken.
  \item Git leent zichzelf voor elke workflow. Git heeft niet één bepaald workflow model meegekregen, dus het is naar wens te gebruiken. Bijvoorbeeld in de vorm van een Subversion style systeem waarbij iedereen zijn wijzigingen naar een centrale server pushed of eentje waarbij er een aangesteld persoon verantwoordelijk is om alle wijzigingen door te voeren, de zogenaamde Integration Manager workflow.
\end{itemize}

\paragraph{Advies} Als je niet afgeschrikt raakt van de commandline kan ik aanraden om Git te gebruiken. Maak je liever gebruik van een goede grafische tool kies je het beste voor Subversion.

\section{Gescheiden werken}

Doordat ik iedereen kan aanraden gebruik te maken van een {\sc scm} systeem, zal het ontwikkelen plaats moeten vinden  op de eigen computer, dus niet op een centrale server. Hierdoor kan iedereen individueel werken, zonder dat werknemers last van elkaar ondervinden omdat iemand bijvoorbeeld wat aanpast.

In de ontwikkelfase, als mensen schermschetsen gaan maken en html pagina's zal dit nog niet veel veranderen aan de workflow. Maar op het moment dat er een website geprogrammeerd moet worden zal het in de meeste gevallen nodig zijn om lokaal ook een webserver te draaien. 

Omdat er veel diversiteit is in programmeertalen en operating systems is het onbegonnen werk om hier alle manieren te vermelden om dit te bereiken, maar er is wel iets waar op gelet moet worden. Zorg er voor dat alle versies van software die op de servers en workstations draaien overeen komen. Stel dat je een bug in je website op moet lossen, als je lokale ontwikkelmachine een afwijkende versie van bijvoorbeeld de webserver heeft waarin deze bug niet voor kan komen wordt het moeilijk om deze op te lossen.

\paragraph{Advies} Verplaats het ontwikkelen van een centrale server naar de workstations zodat iedereen onafhankelijk kan werken, maar zorg er hierbij voor dat software versies gelijk lopen.

\section{Ontwikkelstraat}

De meeste bedrijven maken (naar ik hoop) gebruik van twee ontwikkelomgevingen, eentje waarin ze zelf werken en de live website, die bezoekers te zien krijgen.

In de ideale situatie gaat een project vier verschillende omgevingen door, namelijk: ontwikkeling, test, acceptatie en productie, oftewel de al eerder genoemde OTAP-straat. 

De ontwikkelomgeving bevindt zich op de computers van de werknemers zelf dus daar hoeft weinig over verteld te worden, de andere omgevingen behoeven (klopt dit?) nog wat uitleg.

De testomgeving is een interne webserver die een bepaalde versie draait van het project zodat iedereen deze daar kan testen. In kleine bedrijven kan dit een beetje overkill zijn, maar voor grotere bedrijven waar bepaalde mensen verantwoordelijk zijn voor het testen en bijvoorbeeld QA (quality assurance) kan het erg handig zijn.

De acceptatie omgeving is een afgeschermde webserver die wel bereikt kan worden door de klant. Hierop kan hij een bepaalde versie van het project bekijken zodat hij er feedback op kan geven. Als je bijvoorbeeld de taak hebt gekregen om nieuwe functionaliteit aan een website toe te voegen is het van belang dat de gebruiker deze pas ziet als het helemaal klaar en goedgekeurd is. Er is niks onprofessioneler als bezoekers een niet werkende site te zien krijgen omdat er live aan gewerkt wordt.

Als laatste heb je de productie omgeving, oftewel de website die live staat. Dit spreekt voor zich.

\paragraph{Advies} Maak gebruik van meerdere ontwikkelomgevingen zodat je je klant in een project kan betrekken en bezoekers van de website geen hinder ondervinden.

\section{Backup}



Als er gebruik gemaakt wordt van {\sc scm} is de backup van sourcecode in principe al vrij goed geregeld. Elke versie van een bestand wordt opgeslagen en je kan dus altijd terug naar een vorige versie. Het maken van backups zit er nu bij de meeste mensen al wel goed in, maar vaak genoeg zie je dat deze backups bewaard worden op dezelfde machine. Als deze onverhoopt ten onder gaat ben je alsnog alles kwijt. Net zoals met de situatie bij 4.6 heb je dan een \emph{single point of failure} gecreëerd.

Om echt een goede backupsituatie te hebben moeten deze minstens op een andere machine of bijvoorbeeld een externe hardeschijf worden bewaard. Het liefste ook nog op een andere locatie, want ook al heb je alles goed gebackupped, als het pand afbrandt heb je er niks aan.

Tegenwoordig is hosting in de ``cloud'' in opkomst, waarin Amazon voorop loopt met haar Simple Storage Service (S3). Een account bij S3 is een kosteffectieve manier om veel data op te slaan, en er zijn inmiddels veel tools voor beschikbaar om backups gemakkelijk te laten verlopen. Als je het zo weet te scripten dat backups automatisch op een bepaalde tijd worden gemaakt haal je al veel werk uit handen. Het mooie aan S3 is dat alles daar ook nog eens gemirrored wordt. Een opgeslagen backup wordt namelijk op een aantal punten in de wereld opgeslagen. Op deze manier heb je enorm veel zekerheid over je backups.

\subsection{Database}

Om database gegevens van niet kritieke sites te backuppen kan meestal afgedaan worden met een nachtelijke backup. Zoals vermeld, wordt deze het liefst ook nog op andere plekken opgeslagen dan die bepaalde machine. 

De meeste hostingproviders kunnen de backup voor je regelen maar als je dan een backup moet terugzetten moet je vaak contact opnemen met support. Het liefste regelen we de backup dus ook zelf, om niet afhankelijk te zijn van zulke externe factoren.

Er zijn tegenwoordig ontzettend veel scripts en programma's te vinden die het mogelijk maken om een geautomatiseerde backup van je MySQL database te krijgen. Let wel, bijna alle backup opties moeten mysql stoppen om ervoor te zorgen dat data niet veranderd tijdens de backup. Backuppen doe je dus het liefste op tijden dat je site bijna niet bezocht wordt. Een andere manier is om een \emph{master-slave} systeem in te voeren. Hierbij kan je de slave database realtime of wanneer je het wilt laten synchroniseren met de master database. De backup kan je dan vervolgens uitvoeren op de slave. Op deze manier blijft je master database altijd online en ondervinden de bezoekers geen hinder.



\section{Ticketsysteem}

Als een bedrijf begint te groeien en met veel klanten te maken krijgt, kan het leveren van support en het overzien van nieuwe taken werknemers overmeesteren. Bugs en dergelijke (issues) doorkrijgen via de mail kan een tijd goed blijven gaan, maar als er bijvoorbeeld iemand ziek is en deze persoon de enige was met deze mails heb je dus een \emph{single point of failure}. Door een centraal overzicht te creëren sluit je situaties als deze uit en is de informatie voor iedereen beschikbaar.

Je kan er voor kiezen om dit ticketsysteem alleen intern te gebruiken, maar je kan de transparantie van een bedrijf er mee verbeteren als je klanten ook toegang geeft. Zij kunnen dan in één oogopslag zien hoe het met hun tickets gaat en hier weer op reageren. Zo blijven support aanvragen en dergelijke niet verstopt in de e-mail van werknemers maar kan iedereen alles inzien. 

\subsection{Voordelen}

Naast de al genoemde voordelen van een centraal overzicht van support aanvragen en transparantie zijn er nog een aantal voordelen.

\paragraph{Voordelen voor medewerkers:}

\begin{itemize}
  \item Een goed overzicht van taken waar je aan gewerkt hebt, of nog aan moet werken.
  \item Prestatiebevorderend doordat er iets tastbaars te zien is van wat iemand gedaan heeft om iets op te lossen. Een ticket sluiten geeft erg veel voldoening.
\end{itemize}

\paragraph{Voordelen voor het bedrijf:}

\begin{itemize}
  \item Werknemers goed concreet kunnen aansturen door ze issues toe te wijzen.
  \item Bij de tickets kan goed bijgehouden worden hoeveel uur ergens aan is besteed en wat er is gebeurd. Er is dus een centrale plek waar wordt opgeslagen wie hoe lang aan welk project heeft gewerkt, zodat je bijvoorbeeld gemaakte uren professioneel kunt verantwoorden bij je opdrachtgever.
  \item De prestatie van werknemers wordt in zekere mate meetbaar.
\end{itemize}

\subsection{Keuze}

Er zijn werkelijk honderden issue tracking systemen\cite{issuetracking} dus er is altijd wel een pakket te vinden wat aan alle specifieke eisen van een bedrijf voldoet. Wel kan ik sterk aanraden om bij de keuze van een systeem te kijken of deze ook integratie biedt met een {\sc scm} systeem. Zo heb je één plek om een overzicht te krijgen van wat er allemaal gebeurd binnen het bedrijf, wijzigingen in de code, openen en sluiten van issues, etc. Ook kan je een koppeling leggen door het sluiten van tickets vanuit commitmessages mogelijk te maken. Zo kan je snel terugzien hoe een bepaalde issue precies opgelost is.

Bij Fullmoon hebben we uiteindelijk voor Redmine\cite{redmine} gekozen. Naast issuetracking biedt het een goed overzicht van activiteit (per project en algemeen), solide integratie met veel {\sc scm} systemen en een geïntegreerd wiki systeem.

\paragraph{Advies} Maak gebruik van een ticketsysteem om support voor klanten en taken centraal op te slaan. 

\section{Automatisch deployen}

In navolging van onderdeel 4.4, het werken met een ontwikkelstraat, is het van belang dat het deployen van code naar verschillende omgevingen soepel en gestroomlijnd gaat. Als je telkens alles met de hand moet uploaden etc wordt de drempel namelijk te hoog gelegd, en breekt het in op je workflow.

Er zijn een aantal software oplossingen om het deployen te stroomlijnen. Veel hiervan zijn zogeheten build tools, zoals Maven\cite{maven} en Phing\cite{phing}. Dit zijn erg uitgebreide pakketten die het makkelijk maken om je code te bouwen, te compileren. Omdat dit niet echt aan de orde zal zijn voor de meeste webdevelopment bedrijven en omdat het vrij omslachtig is wil ik me hierbij richten op een tool die beter geschikt is, namelijk Capistrano\cite{capistrano}.

Capistrano is een tool geboren in de Ruby on Rails community en is bij uitstek geschikt voor het deployen van nieuwe code. Het koppelt erg goed met een {\sc scm} systeem en neemt erg veel werk uit handen. Hiernaast biedt het de gebruiker bijvoorbeeld ook de mogelijkheid om een \emph{rollback} uit te voeren, als de gedeployde code niet goed blijkt te zijn. Een ander voordeel is het feit dat de eindgebruiker de nieuwe website pas te zien krijgt als deze in zijn geheel online staat, er kunnen dus geen bugs ontstaan door het feit dat een nieuwe wijziging pas voor de helft is geupload.

Zelf heb ik het voornamelijk gebruikt om nieuwe versies van Ruby on Rails applicaties te deployen, maar het is na een kleine aanpassing ook uitermate geschikt voor bijvoorbeeld PHP applicaties. Dit doe je door in de root van een project een map genaamd config aan te maken, waarin zich een \texttt{deploy.rb} bestand bevindt. Dit is het ``recept'' wat Capistrano gaat gebruiken om zijn werk te kunnen doen. Hierin staat bijvoorbeeld de locatie van de web en {\sc scm} server, naar welke map alles geupload moet worden, etc.

Met behulp van de Capistrano Multistage plugin\cite{capistranomultistage} kan je verschillende stages (omgevingen) aangeven. Dus bijvoorbeeld acceptatie, of productie. Als alles goed is ingesteld kan je met één commando code naar de gewenste omgeving deployen. Om code naar de acceptatie omgeving te uploaden voer je bijvoorbeeld dit in:

\begin{quote}
  \texttt{cap acceptatie deploy}
\end{quote}

In de bijlagen is een recept te vinden wat ik heb gebruikt bij Fullmoon om hun PHP applicaties succesvol te kunnen deployen en een link naar een goede tutorial om met Capistrano aan de slag te gaan.

\paragraph{Advies} Ik kan aanraden om gebruik te maken van Capistrano om het updaten van code in verschillende omgevingen te vergemakkelijken.
