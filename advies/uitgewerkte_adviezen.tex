\chapter{Uitgewerkte adviezen}

\section{Introductie}

In dit gedeelte van het document wordt dieper op de eerder opgestelde adviezen ingegaan. In sommige gevallen worden er een aantal opties aangedragen waarna de persoonlijke voorkeur van de auteur wordt uitgesproken.

\paragraph{N.B. Om de adviezen toegankelijk te houden voor de meeste bedrijven en studenten zijn de adviezen en keuzes gebaseerd op open source software.}

\section{{\sc scm} systeem}

\subsection{Voordelen}

Gebruik maken van een {\sc scm} systeem biedt ontzettend veel voordelen. Het opslaan van verschillende versies van bestanden tijdens het ontwikkelproces is van onmisbaar belang. Het biedt veiligheid want men kan altijd terugkeren naar een vorige versie, wanneer er bijvoorbeeld een fout in de code is geslopen. Het zorgt er ook voor dat men goed kan samenwerken omdat elke werknemer individueel kan werken aan zijn of haar eigen versie van een project. Hierdoor kan het ook een overzicht bieden van wie wat doet, men kan precies zien wat is aangepast in een bepaald bestand en door wie.

Naast deze -- op zich voor de hand liggende voordelen -- biedt het ook stabiliteit. Doordat met een {\sc scm} systeem de mogelijkheid hebt om te \emph{branchen} is gelijktijdig werken met meerdere versies van een project mogelijk. Bijvoorbeeld \emph{stable} voor de stabiele versie en een \emph{development} versie waarin gewerkt wordt. Doordat wijzigingen in een speciale ontwikkel branch worden uitgevoerd, blijft je stabiele branch onaangeraakt en daardoor dus altijd stabiel. In een ideale situatie worden alle wijzingingen uitvoerig getest voordat ze in de stabiele versie worden geïntegreerd. Omdat je dus kan werken in een gescheiden branch is het veilig om te experimenteren, hetgeen in mijn ogen een groot voordeel is.

\subsection{Tools}

Tegenwoordig zijn er tientallen {\sc scm} systemen om uit te kiezen. Een greep uit het aanbod: \emph{Subversion, Git, Mercurial} en \emph{Bazaar}. Eigenlijk bieden ze allemaal ongeveer dezelfde functionaliteit, zodat de keuze om hier één van uit te selecteren van andere factoren zal afhangen.

Van dit rijtje is Subversion eigenlijk van de oude school. Het is een systeem dat gebaseerd is op een centrale \emph{repository}, waarin alle wijzigingen worden bijgehouden. De andere behoren tot de zogenaamde {\sc dvcs} familie, oftewel Distributed Concurrent Version System. Dit systeem heeft als voordeel dat er geen centrale server nodig is.

Bij een {\sc dvcs} draait iedereen immers een lokale repository op zijn eigen computer. Bij Subversion moet wel gebruik gemaakt worden van één centrale server, waarmee iedereen verbinding moet maken om te kunnen werken. Omdat je in het geval van een {\sc dvcs} niet afhankelijk bent van een server kun je dus offline en onderweg werken. Hiernaast is het een stuk gemakkelijker en sneller om branches te maken omdat alles lokaal gebeurt, in plaats van over het netwerk. Bij Subversion is dat een tijdrovend bezigheid, terwijl bij een systeem als Git het maken van dezelfde branch slechts enkele seconden zal duren in plaats van minuten. Tijd waarin je niet met het project kunt werken. Doordat het een snel en eenvoudig proces is, wordt je aangemoedigd tot experimenteren (je kunt immers snel even een branch aanmaken om iets uit te proberen) en word je niet uit je workflow gehaald, wat met Subversion wel het geval zou zijn.

In de meeste gevallen richt je een {\sc dvcs} ook zo in dat iedereen wijzigingen verstuurt (\emph{pushed}) naar een centrale server, hetgeen zorgt voor een goed overzicht. Doordat iedereen zelf kiest wat er naar deze server wordt gepushed houd je een nette repository. Deze wordt niet vervuild door wijzigingen die bijvoorbeeld verkeerd waren of waar iemand nog niet mee klaar is.

Een {\sc dvcs} heeft door bovenstaande mogelijkheden al mijn voorkeur, maar Subversion heeft ook iets wat in haar voordeel speelt. Doordat het van de genoemde tools de oudste is, zijn er erg veel verschillende applicaties en pakketten voor beschikbaar, waaronder veel grafische programma's. In tegenstelling tot de andere waarbij het tot nu toe meer een commandline aangelegenheid blijft.

Wanneer je alleen naar de gedistribueerde pakketten bekijkt is er een aantal voordelen waarin Git zich onderscheidt van de rest. Deze zijn als volgt.

\begin{itemize}
  \item Goedkope local branching. Git geeft de mogelijkheid zoveel lokale branches aan te maken als men wil, waarbij het creëren, mergen en deleten hiervan slechts enkele seconde duurt. De andere systemen raden aan dat de beste branch een kloon is van de repository in een andere directory en bieden niet deze handigheid.
  \item Git is ontzettend snel\cite{whygitisbetterthanx}. Omdat het ontworpen is voor het werken aan de Linux kernel, waren het gebruik maken van grote repositories en snelheid uitgangspunten tijdens de ontwikkeling, en dat is goed te merken.
  \item Git leent zichzelf voor elke workflow. Het heeft niet één bepaald workflow model meegekregen, dus is het naar eigen inzicht te gebruiken. Bijvoorbeeld in de vorm van een Subversion-style systeem waarbij iedereen zijn wijzigingen naar een centrale server pushed. Maar ook de zogenaamde \emph{Integration Manager} workflow is mogelijk, waarbij er één persoon verantwoordelijk is om alle wijzigingen in een project door te voeren.
\end{itemize}

\paragraph{Advies:} Als men niet wordt afgeschrikt door de commandline wordt aangeraden gebruik te maken van Git. Maakt men liever gebruik van een goede grafische tool dan kan men het beste voor Subversion kiezen.

\section{Gescheiden werken}

Aangezien iedereen aangeraden wordt om gebruik te maken van een {\sc scm} systeem, zal het ontwikkelen plaats moeten vinden op de eigen computer, dus niet op een centrale server. Hierdoor kan iedereen individueel werken, zonder dat collega's last van elkaar ondervinden doordat ze aan hetzelfde project bezig zijn.

In de ontwikkelfase, wanneer mensen bijvoorbeeld schermschetsen en HTML pagina's gaan maken zal dit nog niet veel veranderen aan de workflow. Maar op het moment dat er een website geprogrammeerd moet worden zal het in de meeste gevallen nodig zijn om lokaal ook een webserver te draaien. 

Omdat er veel diversiteit is in programmeertalen en operating systems, is het onbegonnen werk om hier alle manieren te vermelden om dit te bereiken, maar er is wel iets waar op gelet moet worden. Zorg er voor dat alle versies van software die op de servers en workstations draaien overeen komen. Stel dat een bug in een website opgelost moet worden, als de workstations een afwijkende versie draaien van bijvoorbeeld de webserver waarin deze bug niet voor kan komen wordt het moeilijk om deze op te lossen.

\paragraph{Advies:} Verplaats het ontwikkelen van een centrale server naar de workstations zodat iedereen onafhankelijk kan werken, maar zorg er hierbij voor dat software versies overeen komen.

\section{Ontwikkelstraat}

De meeste bedrijven zullen hopelijk al gebruik maken van twee ontwikkelomgevingen, een waarin men zelf werkt en de live website, die bezoekers te zien krijgen.

In de ideale situatie gaat een project vier verschillende omgevingen door, namelijk: ontwikkeling, test, acceptatie en productie, oftewel de al eerder genoemde OTAP-straat. 

De ontwikkelomgeving bevindt zich op de computers van de medewerkers zelf dus daar hoeft weinig over verteld te worden, maar de andere omgevingen behoeven nog wat uitleg.

De testomgeving is een interne webserver die een bepaalde versie van het project draait, zodat iedereen die daar kan testen. Bij kleine bedrijven kan dit een beetje overkill zijn, maar voor grotere bedrijven waar bepaalde mensen verantwoordelijk zijn voor het testen en QA (Quality Assurance) kan het erg handig zijn.

De acceptatieomgeving is een afgeschermde webserver die wel toegankelijk is voor de klant. Deze kan hierop een bepaalde versie van het project bekijken en hier feedback op geven. Wanneer iemand bijvoorbeeld de taak heeft gekregen om nieuwe functionaliteit aan een website toe te voegen is het van belang dat de gebruiker deze pas ziet wanneer het helemaal klaar en goedgekeurd is. Het is tamelijk onprofessioneel als bezoekers een niet werkende site te zien krijgen, omdat er live aan gewerkt wordt.

Ten slotte heb je de productieomgeving: de live website, dit spreekt voor zich.

\paragraph{Advies:} Maak gebruik van meerdere ontwikkelomgevingen, zodat de klant in een project betrokken kan worden en bezoekers van de website geen hinder ondervinden van de werkzaamheden.

\section{Backup}

Indien er gebruik gemaakt wordt van {\sc scm} is de backup van broncode in principe al vrij goed geregeld. Iedere versie van een bestand wordt opgeslagen en men kan dus altijd terug naar een vorige versie. Het regelmatig maken van backups wordt gelukkig door de meeste mensen al op waarde geschat, maar vaak genoeg zie je dat deze backups bewaard worden op hetzelfde systeem. Wanneer deze onverhoopt ten onder gaat ben je alsnog alles kwijt. Zo heb je een  \emph{single point of failure} gecreëerd.

Om een echt goede backupsituatie te hebben moet deze ten minste op een andere machine of bijvoorbeeld een externe harde schijf worden bewaard. Het verdient de voorkeur om de backup ook nog op een fysiek andere locatie te hebben, want in geval van brand is niets veilig.

Tegenwoordig is hosting in de ``cloud'' in opkomst, waarin Amazon voorop loopt met haar Simple Storage Service (S3). Een account bij S3 is een betrekkelijk voordelige manier om veel data op te slaan. Er zijn inmiddels ook al veel tools voor beschikbaar om het maken van backups gemakkelijk te laten verlopen. Wanneer men er voor kan zorgen dat backups automatisch op vaste tijdstippen worden gemaakt geeft het een gevoel van veiligheid en is het tijdsbesparend. Een groot voordeel van S3 is dat alles daar ook nog eens gemirrored wordt. Alle bestanden op hun systeem worden namelijk op diverse locaties in de wereld opgeslagen. Op deze manier heb je enorm veel zekerheid over je backups.

Als men er voor kiest om gebruik te maken van S3 zijn er veel tools waar je uit kan kiezen.\cite{amazontools} De voorkeur van de auteur ligt bij s3sync\cite{s3sync}, wat het eenvoudig maakt om uploads te automatiseren door middel van scripts.

\subsection{Database backups}

Bij de meeste hostingproviders kan gebruik gemaakt worden van hun backupservice om databases te archiveren. Maar op het moment dat deze nodig zijn moet er vaak contact opgenomen worden met de support-afdeling. Bij voorkeur verzorgt men deze backups dus ook zelf, om niet afhankelijk te zijn van zulke externe factoren.

Er zijn verschillende manieren om backups te maken van een MySQL database. Let wel, bijna al deze manieren moeten {\sc mysql} stoppen (of zetten hier een lock op) om ervoor te zorgen dat de inhoud van de databases niet verandert tijdens de backup. Backups maken doe je dus bij voorkeur op tijden dat de site nauwelijks bezocht wordt. Een andere manier is om een \emph{master-slave} systeem in te voeren, waarbij gebruik gemaakt wordt van twee verschillende databases. Hierbij kan de slave database realtime of op gezette tijden gesynchroniseerd worden met de master database. De backup kan dan vervolgens worden uitgevoerd op de slave, die zonder problemen gestopt kan worden. Waardoor de master database altijd online blijft en de bezoekers geen hinder ondervinden van het backupproces.

{\sc mysql} levert mysqldump mee, waardoor het triviaal maakt om backups te maken. In de bijlagen is een eenvoudig script bijgevoegd dat gebruik maakt van mysqldump en s3sync. Hiermee kan elke avond een backup gemaakt worden die naar Amazon S3 wordt geupload.

\paragraph{Advies:} Zorg voor regelmatige backups en bewaar deze op meerdere plaatsen zodat er altijd zekerheid is over de veiligheid van data.

\section{Ticketsysteem}

Wanneer een bedrijf begint te groeien en met veel klanten te maken krijgt, kan het leveren van support en het overzien van nieuwe taken werknemers overmeesteren. Bugs en verzoeken (issues) doorkrijgen via de mail kan een tijd lang goed blijven gaan, maar wanneer er bijvoorbeeld iemand ziek is en deze persoon de enige ontvanger was van deze mails heb je dus net zoals bij punt 4.5 een \emph{single point of failure}. Door een centraal overzicht te creëren sluit je situaties als deze uit en is de informatie voor iedereen beschikbaar.

Men kan er voor kiezen om dit ticketsysteem alleen intern te gebruiken, maar de transparantie van een bedrijf kan er mee verbeterd worden wanneer de klanten ook toegang hebben. Zij kunnen dan in één oogopslag zien hoe het met hun tickets gaat en hier weer op reageren. Zo blijven bijvoorbeeld supportaanvragen niet verstopt in de e-mail van één werknemer maar is alles algemeen beschikbaar. 

\subsection{Voordelen}

Naast de al reeds genoemde voordelen van een centraal overzicht van supportaanvragen en transparantie, zijn er nog enkele voordelen te noemen.

\paragraph{Voordelen voor medewerkers:}

\begin{itemize}
  \item Goed overzicht van taken waar aan gewerkt moet worden en waar aan gewerkt is.
  \item Prestatiebevorderend omdat het zichtbaar wordt gemaakt wat iemand heeft gedaan om iets op te lossen. Een ticket sluiten geeft erg veel voldoening.
\end{itemize}

\paragraph{Voordelen voor het bedrijf:}

\begin{itemize}
  \item Werknemers kunnen goed en concreet aangestuurd worden door ze issues toe te wijzen.
  \item Bij de tickets kan goed bijgehouden worden hoeveel uur ergens aan is besteed en wat er is gebeurd. Er is dus een centrale plek waar wordt opgeslagen wie en hoe lang aan welk project heeft gewerkt, zodat de gemaakte uren professioneel verantwoord kunnen worden bij de opdrachtgever.
  \item De prestaties van werknemers wordt in zekere mate meetbaar.
\end{itemize}

\subsection{Keuze}

Er is werkelijk een overvloed aan aanbod van issue tracking systemen\cite{issuetracking} dus er is altijd wel een pakket te vinden dat aan alle specifieke eisen van een bedrijf voldoet. Wel wordt sterk aangeraden om bij de de keuze van een systeem te kijken of dit ook integratie biedt met een {\sc scm} systeem. Zo heb je één plek om een overzicht te krijgen van wat er allemaal gebeurt binnen het bedrijf, wijzigingen in de code, openen en sluiten van issues, etc. Ook kan men zo een koppeling leggen door het sluiten van tickets vanuit commitmessages mogelijk te maken. Zodat men snel kan terugzien hoe een bepaalde issue precies is opgelost.

Bij Fullmoon hebben we uiteindelijk voor Redmine\cite{redmine} gekozen. Naast issuetracking biedt het een goed overzicht van activiteit per project en algemeen, solide integratie met veel {\sc scm} systemen en een geïntegreerd wiki systeem.

\paragraph{Advies:} Maak gebruik van een ticketsysteem om support voor klanten en taken voor medewerkers centraal op te slaan. 

\section{Automatisch deployen}

In navolging van onderdeel 4.4, het werken met een ontwikkelstraat, is het van belang dat het deployen van code naar verschillende omgevingen soepel en gestroomlijnd gaat. Wanneer men telkens alles handmatig moet uploaden wordt de drempel namelijk te hoog, en gaat dit ten koste van de workflow.

Er zijn een aantal softwareoplossingen om het deployen te stroomlijnen. Veel hiervan zijn zogeheten build tools, zoals Maven\cite{maven} en Phing\cite{phing}. Dit zijn erg uitgebreide pakketten die het eenvoudig maken om code te bouwen (\emph{compilen}). Omdat dit niet echt aan de orde zal zijn voor de meeste webdevelopment bedrijven en omdat het vrij omslachtig is zal de verdere uitwerking van dit onderdeel gebaseerd zijn op een tool die beter geschikt is, namelijk Capistrano\cite{capistrano}.

Capistrano is een tool geboren in de Ruby on Rails community en is bij uitstek geschikt voor het deployen van nieuwe code. Het koppelt erg goed met een {\sc scm} systeem en neemt veel werk uit handen. Hiernaast biedt het de gebruiker de mogelijkheid om een \emph{rollback} uit te voeren, wanneer de gedeployde code niet goed blijkt te zijn. Een ander voordeel is het feit dat de eindgebruiker de nieuwe website pas te zien krijgt wanneer deze in zijn geheel online is. Op deze wijze kunnen er geen bugs ontstaan doordat een nieuwe wijziging pas voor de helft is geupload.

De tool wordt voornamelijk gebruikt om nieuwe versies van Ruby on Rails applicaties te deployen, maar het is na een kleine aanpassing ook uitermate geschikt voor bijvoorbeeld PHP applicaties. Dit doe je door in de root van een project een map genaamd config aan te maken, waarin zich een \texttt{deploy.rb} bestand bevindt. Dit is het ``recept'' dat Capistrano gaat gebruiken om zijn werk te kunnen doen. Hierin staan bijvoorbeeld de locaties van de web- en {\sc scm} server, naar welke map alles geupload moet worden, etc.

Met behulp van de Capistrano Multistage plugin\cite{capistranomultistage} kan men verschillende stages (omgevingen) aangeven. Dus bijvoorbeeld acceptatie of productie. Als alles goed is ingesteld kan met één commando code naar de gewenste omgeving worden gedeployed. Om code naar de acceptatie omgeving te uploaden kan bijvoorbeeld dit ingevoerd worden:

\begin{quote}
  \texttt{cap acceptatie deploy}
\end{quote}

In de bijlagen is het recept te vinden dat nu gebruikt wordt bij Fullmoon om hun PHP applicaties succesvol naar verschillende omgevingen te kunnen deployen.

\paragraph{Advies:} Er wordt aangeraden om gebruik te maken van Capistrano om het deployen van code in verschillende omgevingen te vergemakkelijken.
