\chapter{Uitgewerkte adviezen}

\section{Introductie}

In dit gedeelte van het document zal ik dieper in gaan op de adviezen die ik net heb opgesteld. Ik zal een aantal opties aandragen waarna ik mijn persoonlijke voorkeur uitspreek.

Er is geen \'{e}\'{e}n bedrijf hetzelfde, iedereen werkt bijvoorbeeld weer met andere programmeertalen. Om de grootte van dit document niet ernstig uit de klauwen te laten lopen zal ik mij richten op twee werkomgevingen waarbij een Interactieve Media student terecht kan komen. Namelijk, een bedrijf wat developed in PHP en eentje die werkt met Ruby on Rails.

\section{{\sc scm} systeem}

\subsection{Voordelen}

Gebruik maken van een {\sc scm} systeem bied ontzettend veel voordelen. Het opslaan van verschillende versies van bestanden tijdens het ontwikkelproces is van onmisbaar belang. Het biedt je veiligheid want je kan altijd terug gaan naar een vorige versie als er bijvoorbeeld een fout in de code is geslopen. Het zorgt er ook voor dat je goed kan samenwerken omdat elke werknemer individueel kan werken aan zijn of haar eigen versie van een project. Hierdoor kan het ook een overzicht bieden van wie wat doet, je kan precies zien wat is aangepast in een bepaald bestand en door wie.

Naast deze op zich voor de hand liggende voordelen biedt het ook stabiliteit. Doordat je met een {\sc scm} systeem de mogelijkheid hebt om te \emph{branchen} kan je gelijktijdig meerdere versies van een codebase hebben. Bijvoorbeeld \emph{stable} en \emph{development}. Doordat je wijzigingen in een speciale werk branch uitvoert, heb je altijd een stabiele branch. Nadat alle wijzigingen uitvoerig zijn getest kunnen ze in de stabiele versie worden ge\"{i}ntegreerd. Dit bevorderd ook experimentatie, omdat het weinig moeite kost om te schakelen tussen verschillende versies en omdat het veilig is, is het ``goedkoop'' om dingen uit te proberen.

\subsection{Tools}

Tegenwoordig zijn er vele {\sc scm} systemen om uit te kiezen. Een greep uit het aanbod: \emph{Subversion, Git, Mercurial} en \emph{Bazaar}. Eigenlijk bieden ze allemaal ongeveer dezelfde functionaliteit dus de keuze om \'{e}\'{e}n hiervan uit te kiezen zal van andere factoren afhangen.

Van dit rijtje is Subversion eigenlijk van de oude school. Het is een systeem wat gebaseerd is op een centrale repository waar alle wijzigingen in bijgehouden worden. De andere behoren tot de zogenaamde {\sc dvcs} familie, oftewel Distributed Concurrent Version System.

Het voordeel van een {\sc dvcs} is dat je geen server nodig hebt om een repository op te slaan, dit kan gewoon op de workstations zelf. Bij Subversion heb je \'{e}\'{e}n centrale server waar iedereen verbinding mee moet leggen om te kunnen werken. Bij een systeem als bijvoorbeeld Git kan je ook lokaal commits maken in plaats van dat je elke keer je wijzigingen hoeft op te sturen naar de server. 

Naast het feit dat je dus niet per se een verbinding met de server nodig hebt om te kunnen werken is het gemakkelijker en sneller om branches te maken. Elke werknemer kan een lokale development branch aanmaken waarin al het werk gedaan wordt. Hij of zij kan naar hartelust wijzigingen aanbrengen want zijn collega's zien deze pas als hij ze daadwerkelijk opstuurt. Bij een systeem als Subversion zouden zijn collega's gelijk al zijn wijzigingen zien, wat experimentatie af kan schrikken.

Een {\sc dvcs} wint het in mijn ogen door deze voordelen al van Subversion maar er is een gegeven wat erg in het voordeel van Subversion is. Doordat het van de genoemde tools de oudste is zijn er erg veel verschillende applicaties en pakketten voor beschikbaar. Zo zijn er erg veel grafische programma's om met Subversion te kunnen werken, in tegenstelling tot de andere die tot nu toe meer commandline aangelegenheden zijn.

Als je alleen de gedistribueerde pakketten bekijkt zijn er een aantal voordelen die Git hierin weer afscheid van de rest. Ik zal ze kort benoemen.

\begin{itemize}
  \item Goedkope local branching. Het is snel en makkelijk om een nieuwe branch aan te maken waarin je wat ide\"{e}en uit kunt proberen om deze daarna weer terug te mergen mochten ze bevallen. De andere systemen raden aan dat de beste branch een kloon is van de repository in een andere directory.
  \item Git is ontzettend snel. Naast het \emph{pullen} en \emph{pushen} van data naar anderen, zijn er weinig acties die van iets anders gebruik maken dan de harddisk. Omdat het ontworpen is voor gebruik aan de Linux kernel, waren gebruik maken van grote repositories en snelheid uitgangspunten tijdens te ontwikkeling.
  \item Git leent zichzelf voor elke workflow. Git heeft niet \'{e}\'{e}n bepaald workflow model meegekregen, dus het is naar wens te gebruiken. Bijvoorbeeld in de vorm van een Subversion style systeem waarbij iedereen zijn wijzigingen naar een centrale server pushed of eentje waarbij er een aangesteld persoon verantwoordelijk is om alle wijzigingen door te voeren, de zogenaamde Integration Manager workflow.
\end{itemize}

\paragraph{Advies} Als je niet afgeschrikt raakt van de commandline kan ik aanraden om Git te gebruiken. Maak je liever gebruik van een goede grafische tool kies je het beste voor Subversion.

\section{Gescheiden werken}



\section{Ontwikkelstraat}



\section{Backup}



\section{Ticketsysteem}

Als een bedrijf begint te groeien en met veel klanten te maken krijgt, kan het leveren van support en het overzien van nieuwe taken werknemers overmeesteren. Bugs en dergelijke (issues) doorkrijgen via de mail kan een tijd goed blijven gaan, maar als deze niet centraal worden opgeslagen heeft het weinig nut. Om een goed overzicht te hebben is het goed om een ticketsysteem in gebruik te nemen.

Je kan er voor kiezen om dit alleen intern te gebruiken, maar je kan de transparantie van een bedrijf er mee verbeteren als je klanten hier ook toegang toe geeft. Zij kunnen dan in \'{e}\'{e}n oogopslag zien hoe het met hun tickets gaat.

\subsection{Voordelen}

Voordelen voor medewerkers:

\begin{itemize}
  \item Een goed overzicht van taken waar je aan gewerkt hebt, of nog aan moet werken.
  \item Prestatiebevorderend doordat je iets tastbaars hebt van wat je allemaal al gedaan hebt.
\end{itemize}

Voordelen voor het bedrijf:

\begin{itemize}
  \item Werknemers goed concreet kunnen aansturen door ze issues toe te wijzen.
  \item Bij de tickets kan goed bijgehouden worden hoeveel uur ergens aan is besteed en wat er is gebeurd. Er is dus een centrale plek waar wordt opgeslagen wie hoe lang aan welk project heeft gewerkt, zodat je bijvoorbeeld gemaakte uren professioneel kunt verantwoorden bij je opdrachtgever.
  \item De prestatie van werknemers wordt in zekere mate meetbaar.
\end{itemize}

\subsection{Keuze}

Er zijn werkelijk honderden issue tracking systemen\cite{issuetracking} dus er is altijd wel een pakket te vinden wat aan alle specifieke eisen van een bedrijf voldoet. Wel kan ik sterk aanraden om bij de keuze van een systeem te kijken of deze ook integratie biedt met een {\sc scm} systeem. Dit heeft als voordeel dat je de status van tickets kan wijzigen vanuit commit messages en dat je dan \'{e}\'{e}n plek hebt waar je een overzicht hebt van wat er allemaal gebeurd binnen het bedrijf. Wijzigingen in de code, openen en sluiten van issues, etc.

\section{Automatisch deployen}

In navolging van onderdeel 4.4, het werken met een ontwikkelstraat, is het van belang dat het deployen van code naar verschillende omgevingen soepel en gestroomlijnd gaat. Als je telkens alles met de hand moet uploaden etc wordt de drempel namelijk te hoog gelegd, en is het niet fijn werken.

Dit kan je op een aantal manieren bereiken. Veel oplossingen zijn zogeheten build tools, zoals Maven\cite{maven} en Phing\cite{phing}. Dit zijn erg uitgebreide pakketten die het makkelijk maken om je code te bouwen, te compileren. Omdat dit niet echt aan de orde zal zijn voor de meeste webdevelopment bedrijven en omdat het vrij omslachtig is wil ik me hierbij richten op een tool die meer voor hun geschikt is, namelijk Capistrano\cite{capistrano}.

Capistrano is een tool geboren in de Ruby on Rails community en is bij uitstek geschikt voor het deployen van nieuwe code. Het koppelt erg goed met een {\sc scm} systeem en neemt erg veel werk uit handen. Hiernaast biedt het de gebruiker bijvoorbeeld ook de mogelijkheid om een \emph{rollback} uit te voeren, als de gedeployde code niet goed blijkt te zijn. Een ander voordeel is het feit dat de eindgebruiker de nieuwe website pas te zien krijgt als hij helemaal is overgekomen, er kunnen dus geen bugs ontstaan door het feit dat een nieuwe wijziging pas voor de helft is geupload.

Zelf gebruik ik het waar het voor bedoeld is, om Ruby on Rails applicaties te deployen, maar het is na een kleine aanpassing ook uitermate geschikt voor bijvoorbeeld PHP applicaties. Dit doe je door in de root van een project een map genaamd config aan te maken, waarin zich een ''deploy.rb'' bestand bevindt. Dit is het recept wat Capistrano gaat gebruiken om zijn werk te kunnen doen. Hierin staat bijvoorbeeld de locatie van de web en {\sc scm} server, naar welke map alles geupload moet worden, etc.

Met behulp van de Capistrano Multistage plugin\cite{capistranomultistage} kan je verschillende stages (omgevingen) aangeven. Dus bijvoorbeeld acceptatie, of productie. Als alles goed is ingesteld kan je met \'{e}\'{e}n commando code naar de gewenste omgeving deployen.

\begin{quote}
  \texttt{cap acceptatie deploy}
\end{quote}

In de bijlagen is een recept te vinden wat ik heb gebruikt bij Fullmoon om hun PHP applicaties succesvol te kunnen deployen.

\paragraph{Advies} Ik kan aanraden om gebruik te maken van Capistrano om het updaten van code in verschillende omgevingen te vergemakkelijken.
