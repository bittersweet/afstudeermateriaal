\chapter{Uitgewerkte adviezen}

\section{Introductie}

In dit gedeelte van het document zal ik dieper ingaan op de adviezen die ik net heb opgesteld. In sommige gevallen zal ik een aantal opties aandragen waarna ik mijn persoonlijke voorkeur uitspreek.

\paragraph{N.B. Om mijn adviezen toegankelijk te houden voor de meeste bedrijven en studenten heb ik mijn adviezen en keuzes gebaseerd op open source software.}

\section{{\sc scm} systeem}

\subsection{Voordelen}

Gebruik maken van een {\sc scm} systeem biedt ontzettend veel voordelen. Het opslaan van verschillende versies van bestanden tijdens het ontwikkelproces is van onmisbaar belang. Het biedt veiligheid want men kan altijd terugkeren naar een vorige versie, wanneer er bijvoorbeeld een fout in de code is geslopen. Het zorgt er ook voor dat men goed kan samenwerken omdat elke werknemer individueel kan werken aan zijn of haar eigen versie van een project. Hierdoor kan het ook een overzicht bieden van wie wat doet, men kan precies zien wat is aangepast in een bepaald bestand en door wie.

Naast deze -- op zich voor de hand liggende voordelen -- biedt het ook stabiliteit. Doordat met een {\sc scm} systeem de mogelijkheid hebt om te \emph{branchen} is gelijktijdig werken met meerdere versies van een project mogelijk. Bijvoorbeeld \emph{stable} voor de stabiele versie en een \emph{development} versie waarin gewerkt wordt. Doordat wijzigingen in een speciale ontwikkel branch worden uitgevoerd, blijft je stabiele branch onaangeraakt en daardoor dus altijd stabiel. In een ideale situatie worden alle wijzingingen uitvoerig getest voordat ze in de stabiele versie worden geïntegreerd. Omdat je dus kan werken in een gescheiden branch is het veilig om te experimenteren, hetgeen in mijn ogen een groot voordeel is.

\subsection{Tools}

Tegenwoordig zijn er tientallen {\sc scm} systemen om uit te kiezen. Een greep uit het aanbod: \emph{Subversion, Git, Mercurial} en \emph{Bazaar}. Eigenlijk bieden ze allemaal ongeveer dezelfde functionaliteit, zodat de keuze om hier één van uit te selecteren van andere factoren zal afhangen.

Van dit rijtje is Subversion eigenlijk van de oude school. Het is een systeem dat gebaseerd is op een centrale \emph{repository}, waarin alle wijzigingen worden bijgehouden. De andere behoren tot de zogenaamde {\sc dvcs} familie, oftewel Distributed Concurrent Version System. Die als voordeel heeft dat er geen centrale server nodig is.

Bij een {\sc dvcs} draait iedereen immers een lokale repository op zijn eigen computer. Bij Subversion moet wel gebruik gemaakt worden van één centrale server, waarmee iedereen verbinding moet maken om te kunnen werken. Omdat je in het geval van een {\sc dvcs} niet afhankelijk bent van een server kan je dus offline en onderweg werken. Hiernaast is het een stuk gemakkelijker en sneller om branches te maken omdat alles lokaal gebeurt, in plaats van over het netwerk. Bij Subversion is dat een tijdrovend bezigheid, terwijl bij een systeem als Git het maken van dezelfde branch slechts enkele seconden zal duren in plaats van minuten. Tijd waarin je niet met het project kunt werken. Doordat het een snel en eenvoudig proces is, wordt je aangemoedigd tot experimenteren (je kan immers snel even een branch aanmaken om iets uit te proberen) en word je niet uit je workflow gehaald, wat met Subversion wel het geval zou zijn.

In de meeste gevallen richt je een {\sc dvcs} ook zo in dat iedereen wijzigingen verstuurt (\emph{pushed}) naar een centrale server, hetgeen zorgt voor een goed overzicht. Doordat iedereen zelf kiest wat er naar deze server wordt gepushed houd je een nette repository. Deze wordt niet vervuild door wijzigingen die bijvoorbeeld verkeerd waren of waar iemand nog niet mee klaar is.

Een {\sc dvcs} heeft door bovenstaande mogelijkheden al mijn voorkeur, maar Subversion heeft ook iets wat in haar voordeel speelt. Doordat het van de genoemde tools de oudste is, zijn er erg veel verschillende applicaties en pakketten voor beschikbaar, waaronder veel grafische programma's. In tegenstelling tot de andere waarbij het tot nu toe meer een commandline aangelegenheid blijft.

Wanneer je alleen naar de gedistribueerde pakketten bekijkt zijn er een aantal voordelen waarin Git zich onderscheidt van de rest. Ik zal ze kort benoemen.

\begin{itemize}
  \item Goedkope local branching. Git geeft de mogelijkheid zoveel lokale branches aan te maken als men wil, waarbij het creëren, mergen en deleten hiervan slechts enkele seconde duurt. De andere systemen raden aan dat de beste branch een kloon is van de repository in een andere directory en bieden niet deze handigheid.
  \item Git is ontzettend snel\cite{whygitisbetterthanx}. Omdat het ontworpen is voor het werken aan de Linux kernel, waren het gebruik maken van grote repositories en snelheid uitgangspunten tijdens de ontwikkeling, en dat is goed te merken.
  \item Git leent zichzelf voor elke workflow. Het heeft niet één bepaald workflow model meegekregen, dus is het naar eigen inzicht te gebruiken. Bijvoorbeeld in de vorm van een Subversion-style systeem waarbij iedereen zijn wijzigingen naar een centrale server pushed. Maar ook de zogenaamde \emph{Integration Manager} workflow is mogelijk, waarbij er één persoon verantwoordelijk is om alle wijzigingen in een project door te voeren.
\end{itemize}

\paragraph{Advies} Als men niet wordt afgeschrikt door de commandline kan ik aanraden om Git te gebruiken. Maak men liever gebruik van een goede grafische tool kan men het beste voor Subversion kiezen.

\section{Gescheiden werken}

Aangezien ik iedereen kan aanraden gebruik te maken van een {\sc scm} systeem, zal het ontwikkelen plaats moeten vinden op de eigen computer, dus niet op een centrale server. Hierdoor kan iedereen individueel werken, zonder dat collega's last van elkaar ondervinden doordat ze aan hetzelfde project bezig zijn.

In de ontwikkelfase, wanneer mensen bijvoorbeeld schermschetsen en HTML pagina's gaat maken zal dit nog niet veel veranderen aan de workflow. Maar op het moment dat er een website geprogrammeerd moet worden zal het in de meeste gevallen nodig zijn om lokaal ook een webserver te draaien. 

Omdat er veel diversiteit is in programmeertalen en operating systems is het onbegonnen werk om hier alle manieren te vermelden om dit te bereiken, maar er is wel iets waar op gelet moet worden. Zorg er voor dat alle versies van software die op de servers en workstations draaien overeen komen. Stel dat een bug in een website opgelost moet worden, als de workstations een afwijkende versie draaien van bijvoorbeeld de webserver waarin deze bug niet voor kan komen wordt het moeilijk om deze op te lossen.

\paragraph{Advies} Verplaats het ontwikkelen van een centrale server naar de workstations zodat iedereen onafhankelijk kan werken, maar zorg er hierbij voor dat software versies overeen komen.

\section{Ontwikkelstraat}

De meeste bedrijven zullen hopelijk al gebruik maken van twee ontwikkelomgevingen, een waarin men zelf werkt en de live website, die bezoekers te zien krijgen.

In de ideale situatie gaat een project vier verschillende omgevingen door, namelijk: ontwikkeling, test, acceptatie en productie, oftewel de al eerder genoemde OTAP-straat. 

De ontwikkelomgeving bevindt zich op de computers van de medewerkers zelf dus daar hoeft weinig over verteld te worden, maar de andere omgevingen behoeven nog wat uitleg.

De testomgeving is een interne webserver die een bepaalde versie van het project draait, zodat iedereen die daar kan testen. Bij kleine bedrijven kan dit een beetje overkill zijn, maar voor grotere bedrijven waar bepaalde mensen verantwoordelijk zijn voor het testen en QA (Quality Assurance) kan het erg handig zijn.

De acceptatieomgeving is een afgeschermde webserver die wel toegankelijk is voor door de klant. Die hierop een bepaalde versie van het project kan bekijken en hier feedback op kan geven. Wanneer iemand bijvoorbeeld de taak heeft gekregen om nieuwe functionaliteit aan een website toe te voegen is het van belang dat de gebruiker deze pas ziet wanneer het helemaal klaar en goedgekeurd is. Het is tamelijk onprofessioneel als bezoekers een niet werkende site te zien krijgen, omdat er live aan gewerkt wordt.

Ten slotte heb je de productieomgeving: de live website, dit spreekt voor zich.

\paragraph{Advies} Maak gebruik van meerdere ontwikkelomgevingen, zodat de klant in een project betrokken kan worden en bezoekers van de website geen hinder ondervinden van de werkzaamheden.

\section{Backup}

Als er gebruik gemaakt wordt van {\sc scm} is de backup van sourcecode in principe al vrij goed geregeld. Elke versie van een bestand wordt opgeslagen en je kan dus altijd terug naar een vorige versie. Het maken van backups zit er nu bij de meeste mensen al wel goed in, maar vaak genoeg zie je dat deze backups bewaard worden op dezelfde machine. Als deze onverhoopt ten onder gaat ben je alsnog alles kwijt. Net zoals met de situatie bij 4.6 heb je dan een \emph{single point of failure} gecreëerd.

Om echt een goede backupsituatie te hebben moeten deze minstens op een andere machine of bijvoorbeeld een externe hardeschijf worden bewaard. Het liefste ook nog op een andere locatie, want ook al heb je alles goed gebackupped, als het pand afbrandt heb je er niks aan.

Tegenwoordig is hosting in de ``cloud'' in opkomst, waarin Amazon voorop loopt met haar Simple Storage Service (S3). Een account bij S3 is een kosteffectieve manier om veel data op te slaan, en er zijn inmiddels veel tools voor beschikbaar om backups gemakkelijk te laten verlopen. Als je het zo weet in te richten dat backups automatisch op een bepaalde tijd worden gemaakt haal je al veel werk uit handen. Het mooie aan S3 is dat alles daar ook nog eens gemirrored wordt. Alle bestanden op hun systeem worden namelijk op een aantal punten in de wereld opgeslagen. Op deze manier heb je enorm veel zekerheid over je backups.

Als je er voor kiest om gebruik te maken van S3 zijn er veel tools waar je uit kan kiezen.\cite{amazontools} Zelf gebruik ik het liefste s3sync\cite{s3sync}, wat het eenvoudig maakt om uploads te automatiseren door middel van scripts.

\subsection{Database backups}

De meeste hostingproviders kunnen database backups voor je regelen maar als je er dan beschikking over wilt hebben moet je vaak contact opnemen met de support-afdeling. Het liefste verzorgen we deze backups dus ook zelf, om niet afhankelijk te zijn van zulke externe factoren.

Er zijn een aantal manieren om backups te maken van je MySQL database. Let wel, bijna al deze manieren moeten mysql stoppen (of zetten hier een lock op) om ervoor te zorgen dat data niet veranderd tijdens de backup. Backups maken doe je dus het liefste op tijden dat je site bijna niet bezocht wordt. Een andere manier is om een \emph{master-slave} systeem in te voeren, waarbij je gebruik maakt van twee verschillende databases. Hierbij kan je de slave database realtime of wanneer je het wilt laten synchroniseren met de master database. De backup kan je dan vervolgens uitvoeren op de slave. Op deze manier blijft je master database altijd online en ondervinden de bezoekers geen hinder.

MySQL levert mysqldump mee, wat het erg makkelijk maakt om een backup te maken. In de bijlagen heb ik een eenvoudig script bijgevoegd dat gebruik maakt van mysqldump en s3sync. Hiermee maak ik momenteel elke avond automatisch een backup, die naar Amazon S3 wordt geupload.

\paragraph{Advies} Zorg voor regelmatige backups en bewaar deze op meerdere plaatsen zodat je er altijd bij kunt.

\section{Ticketsysteem}

Als een bedrijf begint te groeien en met veel klanten te maken krijgt, kan het leveren van support en het overzien van nieuwe taken werknemers overmeesteren. Bugs en dergelijke (issues) doorkrijgen via de mail kan een tijd goed blijven gaan, maar als er bijvoorbeeld iemand ziek is en deze persoon de enige was met deze mails heb je dus een \emph{single point of failure}. Door een centraal overzicht te creëren sluit je situaties als deze uit en is de informatie voor iedereen beschikbaar.

Je kan er voor kiezen om dit ticketsysteem alleen intern te gebruiken, maar je kan de transparantie van een bedrijf er mee verbeteren als je klanten ook toegang geeft. Zij kunnen dan in één oogopslag zien hoe het met hun tickets gaat en hier weer op reageren. Zo blijven support aanvragen en dergelijke niet verstopt in de e-mail van werknemers maar kan iedereen alles inzien. 

\subsection{Voordelen}

Naast de al genoemde voordelen van een centraal overzicht van support aanvragen en transparantie zijn er nog een aantal voordelen.

\paragraph{Voordelen voor medewerkers:}

\begin{itemize}
  \item Een goed overzicht van taken waar je aan gewerkt hebt, of nog aan moet werken.
  \item Prestatiebevorderend doordat er iets tastbaars te zien is van wat iemand gedaan heeft om iets op te lossen. Een ticket sluiten geeft erg veel voldoening.
\end{itemize}

\paragraph{Voordelen voor het bedrijf:}

\begin{itemize}
  \item Werknemers goed concreet kunnen aansturen door ze issues toe te wijzen.
  \item Bij de tickets kan goed bijgehouden worden hoeveel uur ergens aan is besteed en wat er is gebeurd. Er is dus een centrale plek waar wordt opgeslagen wie hoe lang aan welk project heeft gewerkt, zodat je bijvoorbeeld gemaakte uren professioneel kunt verantwoorden bij je opdrachtgever.
  \item De prestatie van werknemers wordt in zekere mate meetbaar.
\end{itemize}

\subsection{Keuze}

Er zijn werkelijk honderden issue tracking systemen\cite{issuetracking} dus er is altijd wel een pakket te vinden wat aan alle specifieke eisen van een bedrijf voldoet. Wel kan ik sterk aanraden om bij de keuze van een systeem te kijken of deze ook integratie biedt met een {\sc scm} systeem. Zo heb je één plek om een overzicht te krijgen van wat er allemaal gebeurd binnen het bedrijf, wijzigingen in de code, openen en sluiten van issues, etc. Ook kan je een koppeling leggen door het sluiten van tickets vanuit commitmessages mogelijk te maken. Zo kan je snel terugzien hoe een bepaalde issue precies opgelost is.

Bij Fullmoon hebben we uiteindelijk voor Redmine\cite{redmine} gekozen. Naast issuetracking biedt het een goed overzicht van activiteit (per project en algemeen), solide integratie met veel {\sc scm} systemen en een geïntegreerd wiki systeem.

\paragraph{Advies} Maak gebruik van een ticketsysteem om support voor klanten en taken centraal op te slaan. 

\section{Automatisch deployen}

In navolging van onderdeel 4.4, het werken met een ontwikkelstraat, is het van belang dat het deployen van code naar verschillende omgevingen soepel en gestroomlijnd gaat. Als je telkens alles met de hand moet uploaden etc wordt de drempel namelijk te hoog gelegd, en breekt het in op je workflow.

Er zijn een aantal software oplossingen om het deployen te stroomlijnen. Veel hiervan zijn zogeheten build tools, zoals Maven\cite{maven} en Phing\cite{phing}. Dit zijn erg uitgebreide pakketten die het makkelijk maken om je code te bouwen, te compileren. Omdat dit niet echt aan de orde zal zijn voor de meeste webdevelopment bedrijven en omdat het vrij omslachtig is wil ik me hierbij richten op een tool die beter geschikt is, namelijk Capistrano\cite{capistrano}.

Capistrano is een tool geboren in de Ruby on Rails community en is bij uitstek geschikt voor het deployen van nieuwe code. Het koppelt erg goed met een {\sc scm} systeem en neemt erg veel werk uit handen. Hiernaast biedt het de gebruiker bijvoorbeeld ook de mogelijkheid om een \emph{rollback} uit te voeren, als de gedeployde code niet goed blijkt te zijn. Een ander voordeel is het feit dat de eindgebruiker de nieuwe website pas te zien krijgt als deze in zijn geheel online staat, er kunnen dus geen bugs ontstaan door het feit dat een nieuwe wijziging pas voor de helft is geupload.

Zelf heb ik het voornamelijk gebruikt om nieuwe versies van Ruby on Rails applicaties te deployen, maar het is na een kleine aanpassing ook uitermate geschikt voor bijvoorbeeld PHP applicaties. Dit doe je door in de root van een project een map genaamd config aan te maken, waarin zich een \texttt{deploy.rb} bestand bevindt. Dit is het ``recept'' wat Capistrano gaat gebruiken om zijn werk te kunnen doen. Hierin staat bijvoorbeeld de locatie van de web en {\sc scm} server, naar welke map alles geupload moet worden, etc.

Met behulp van de Capistrano Multistage plugin\cite{capistranomultistage} kan je verschillende stages (omgevingen) aangeven. Dus bijvoorbeeld acceptatie, of productie. Als alles goed is ingesteld kan je met één commando code naar de gewenste omgeving deployen. Om code naar de acceptatie omgeving te uploaden voer je bijvoorbeeld dit in:

\begin{quote}
  \texttt{cap acceptatie deploy}
\end{quote}

In de bijlagen is een recept te vinden wat ik heb gebruikt bij Fullmoon om hun PHP applicaties succesvol te kunnen deployen en een link naar een goede tutorial om met Capistrano aan de slag te gaan.

\paragraph{Advies} Ik kan aanraden om gebruik te maken van Capistrano om het updaten van code in verschillende omgevingen te vergemakkelijken.
